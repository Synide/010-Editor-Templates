//--------------------------------------
//--- 010 Editor v3.0.5 Binary Template
//
// File: modo .lx* template parser
// Author: Gwynne Reddick
// Revision: 1.00
// Purpose: Reads all known chunks in modo *.lxo, *.lxp. *.lxe and *.lxl files
//--------------------------------------


// 15-01-2018 - Synide - Added 'APPV' chunk processing
// 21-02-2018 - Synide - Added 'IASS' Chunk processing
// 21-02-2018 - Synide - Added 'ITEM.VNAM' sub chunk processing


local int haveValidFormat = false;
local ulong numTriSurfVerts; // stores num of verts in 3SRF chunk for use by VRTS chunk
local ulong numTriSurfTris; // stores num of tris in 3SRF chunk for use by TRIS chunk
local ulong numTriSurfTags; // stores num of tags in 3SRF chunk for use by TTGS chunk

// Typedefs for the IFF file
typedef char ID[4];
typedef ulong CSIZE;  // Chunk size
typedef ushort SCSIZE; // Subchunk size


// chunks
struct IFFHEADER;
struct PSCR_CHUNK;
struct VRSN_CHUNK;
struct DESC_CHUNK;
struct PRVW_CHUNK;
struct THUM_CHUNK;
struct ENCO_CHUNK;
struct STAG_CHUNK;
struct TAGS_CHUNK;
struct PRNT_CHUNK;
struct ITEM_CHUNK;
struct ENVL_CHUNK;
struct ACTN_CHUNK;
struct CHNM_CHUNK;
struct REFS_CHUNK;
struct LAYR_CHUNK;
struct PNTS_CHUNK;
struct BBOX_CHUNK;
struct VMPA_CHUNK;
struct VMAP_CHUNK;
struct POLS_CHUNK;
struct VMAD_CHUNK;
struct VMED_CHUNK;
struct PTAG_CHUNK;
struct _3GRP_CHUNK;
struct _3SRF_CHUNK;
struct VRTS_CHUNK;
struct TRIS_CHUNK;
struct VVEC_CHUNK;
struct TTGS_CHUNK;
struct AUTH_CHUNK;
struct CPYR_CHUNK;
struct ANNO_CHUNK;
struct AANI_CHUNK;
struct BAKE_CHUNK;
struct APPV_CHUNK;
struct IASS_CHUNK;

// misc
struct RGBA;
struct POINT_t;
struct VERTINDEX_t;
struct VERTDATA;

// unrecognized chunk/subchunk
struct UNKNOWNCHUNK;

// subchunk reading functions
void readsubchunks(int pos);


enum {              // Item Data Types
    LXItemType_Int              = 0x01,
    LXItemType_Float            = 0x02,
    LXItemType_String           = 0x03,
    LXItemType_Variable         = 0x04,
    LXItemType_Envelope         = 0x10,
    LXItemType_UndefState       = 0x20,     // undefined action channel

    LXItemType_EnvelopeInt      = LXItemType_Envelope | LXItemType_Int,
    LXItemType_EnvelopeFloat    = LXItemType_Envelope | LXItemType_Float,
    LXItemType_EnvelopeString   = LXItemType_Envelope | LXItemType_String,

    LXItemType_FloatAlt         = 0x4e56,   // compatibility with some apps

    LXEnvelopeType_Float        = 0,
    LXEnvelopeType_Int          = 1,
};



//------------------------------------------------------------
// File gets processed here
//------------------------------------------------------------

BigEndian(); 
IFFHEADER header;


// Check for valid header
if(header.groupID != "FORM")
{
    Warning( "File is not a valid IFF file. Template stopped." );
    return -1;
}

switch (header.ifftype)
{
    case "LXPR":
        break;
    case "LXPE":
        break;
    case "LXOB":
        break;
    case "LXPM":
        break;
    case "SYOB":
        break;
    default:
        Warning( "File is not a recognised modo file. Template stopped." );
        return -1;
}


// Read the file as a set of chunks
local ID tag;
local uint size;
while(!FEof())
{
    // Read the chunk tag 
    ReadBytes(tag, FTell(), 4);
    // See which chunk this is
    switch(tag)
    {
        case "PSCR":
            PSCR_CHUNK	PSCR;
            break;
        case "DESC":
            DESC_CHUNK	DESC;
            break;
        case "PRVW":
            PRVW_CHUNK	PRVW;
            break;
        case "VRSN":
            VRSN_CHUNK	VRSN;
            break;
        case "ENCO":
            ENCO_CHUNK  ENCO;
            break;
        case "STAG":
            STAG_CHUNK  STAG;
            break;
        case "THUM":
            THUM_CHUNK   THUM;
            break;
        case "PRNT":
            PRNT_CHUNK   PRNT;
            break;
        case "ITEM":
            ITEM_CHUNK   ITEM;
            break;
        case "ENVL":
            ENVL_CHUNK   ENVL;
            break;
        case "ACTN":
            ACTN_CHUNK   ACTN;
            break;
        case "TAGS":
            TAGS_CHUNK   TAGS;
            break;
        case "REFS":
            REFS_CHUNK   REFS;
            break;
        case "CHNM":
            CHNM_CHUNK   CHNM;
            break;
        case "LAYR":
            LAYR_CHUNK   LAYR;
            break;
        case "PNTS":
            PNTS_CHUNK   PNTS;
            break;
        case "BBOX":
            BBOX_CHUNK   BBOX;
            break;
        case "VMPA":
            VMPA_CHUNK   VMPA;
            break;
        case "VMAP":
            VMAP_CHUNK   VMAP;
            break;
        case "POLS":
            POLS_CHUNK   POLS;
            break;
        case "VMAD":
            VMAD_CHUNK   VMAD;
            break;
        case "VMED":
            VMAD_CHUNK   VMAD;
            break;
        case "PTAG":
            PTAG_CHUNK   PTAG;
            break;
        case "3GRP":
            _3GRP_CHUNK   _3GRP;
            break;
        case "3SRF":
            _3SRF_CHUNK   _3SRF;
            break;
        case "VRTS":
            VRTS_CHUNK   VRTS;
            break;
        case "TRIS":
            TRIS_CHUNK   TRIS;
            break;
        case "VVEC":
            VVEC_CHUNK   VVEC;
            break;
        case "TTGS":
            TTGS_CHUNK   TTGS;
            break;
        case "AUTH":
            AUTH_CHUNK   AUTH;
            break;
        case "(c) ":
            CPYR_CHUNK   CPYR;
            break;
        case "ANNO":
            ANNO_CHUNK   ANNO;
            break;
        case "BAKE":
            BAKE_CHUNK  BAKE;
            break;
        case "AANI":
            AANI_CHUNK  AANI;
            break;
            //SB - 15-1-2018 - Added APPV Chunk processing
        case "APPV":
            APPV_CHUNK  APPV;
            break;
						//SB - 21-02-2018 - Added IASS Chunk processing
        case "IASS":
	        	IASS_CHUNK	IASS;
	        	break;
        default:
            // Unknown chunk
            if ( FTell() < header.size )
            {
                size = ReadUInt( FTell()+4 );
                Printf( "Encountered unknown chunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
                SetBackColor( cNone );
                UNKNOWNCHUNK unknown;
            }
            break;
    }
}



//------------------------------------------------------------
// File header chunk
//------------------------------------------------------------
typedef struct 
{
    ID     groupID<name="ChunkID", fgcolor=cRed>;
    long   size<name="Total Filesize">;
    ID     ifftype<name="IFF Type">;
} IFFHEADER <name="Header", read=IFFHEADER_Read>;

string IFFHEADER_Read(IFFHEADER &header)
{
    string  ext;
    switch (header.ifftype) {
        case "LXPR":
            ext = " (.lxp)";
            break;
        case "LXPE":
            ext = " (.lxe)";
            break;
        case "LXOB":
            ext = " (.lxo)";
            break;
        case "LXPM":
            ext = " (.lxl)";
            break;
        case "SYOB":
            ext = " (.sy)";
            break;
        default:
            ext = "Unknown";
    }
    return SPrintf(ext, header.ifftype + ext);
}



//------------------------------------------------------------
// Chunk definitions.
//------------------------------------------------------------

// PSCR chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=0x000080>;
    CSIZE           size<name="Size">;
    string          scriptpath<name="Script Path">;
    if (sizeof(scriptpath) & 1)
        uchar padding <hidden=true>;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PSCR_CHUNK <name="PSCR", read=fn_Read_PSCR>;

string fn_Read_PSCR(PSCR_CHUNK &pscr)
{
    return pscr.scriptpath;
}


// DESC chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    string          type<name="Type">;
    if (sizeof(type) & 1)
        uchar padding <hidden=true>;
    string    text<name="Text">;
    if (sizeof(text) & 1)
        uchar padding <hidden=true>;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} DESC_CHUNK <read=DESC_CHUNKRead, name="DESC">;

string DESC_CHUNKRead(DESC_CHUNK &desc)
{
    return desc.type;
}


// THUM chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    char            thumbData[size]<name="Thumbnail Image Data">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} THUM_CHUNK <name="THUM">;


// PRVW chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int pos = FTell();
    unsigned short  width<name="Width">;
    unsigned short  height<name="Height">;
    unsigned long   type<name="Type">;
    unsigned long   flags<format=binary, name="Flags">; 
    char            previewData[size - (FTell() - pos)]<name="Preview Image Data">;
    

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PRVW_CHUNK <read=fn_Read_PRVW, name="PRVW">;

string fn_Read_PRVW(PRVW_CHUNK &prvw)
{
    string s;
    return SPrintf(s, "width: %d height: %d", prvw.width, prvw.height);
}


// VRSN chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    ulong           majorVersion<name="Major Version">;
    ulong           minorVersion<name="Minor Version">;
    string          application<name="Application   ">;
    if (sizeof(application) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VRSN_CHUNK <read=fn_Read_VRSN, name="VRSN">;

string fn_Read_VRSN(VRSN_CHUNK &version)
{
    return version.application;
}


// PRNT chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int pos = FTell();
    string          parent<name="Parent">;
    if (sizeof(parent) & 1)
        uchar padding <hidden=true>;
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PRNT_CHUNK <name="PRNT">;



// ENCO chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    unsigned long   encoding<name="Encoding">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENCO_CHUNK <name="ENCO">;


// STAG chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    ID              tag<name="Tag ID">;
    string          file<name="Filename">;
    if (sizeof(file) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} STAG_CHUNK <read=fn_Read_STAG, name="STAG">;

string fn_Read_STAG(STAG_CHUNK &stag)
{
    string s;
    return SPrintf(s, "%s", stag.file);
}


// ITEM chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    string          type<name="Type">;
    if (sizeof(type) & 1)
        uchar padding <hidden=true>;

    string          username<name="UserName">;
    if (sizeof(username) & 1)
        uchar padding <hidden=true>;

    ulong   id<name="ID">;
    local int subchunks = FTell();
    // Read the subchunks
    while( FTell() - pos < size )
        fn_ReadItemSubchunks(subchunks);
    
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHUNK <read=fn_Read_ITEM, name="ITEM">;

string fn_Read_ITEM(ITEM_CHUNK &chunk)
{
    string s;
    string name = chunk.username;
    if (Strlen(chunk.username) == 0)
    	name = chunk.VNAM[0].name;
    return SPrintf(s, "Type: '%s' Name: '%s'", chunk.type, name);
}

// ENVL chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    local ushort    tmpIndex;
    tmpIndex = ReadUShort(FTell());
    if (tmpIndex < 0xFF00)
        ushort      index<name="Index">;
    else
        ulong       index<name="Index">;
    ulong           type<name="Type", read=fn_Read_Type>;
    local int subchunks = FTell();
    while( FTell() - pos < size )
        fn_Read_ENVL_Subchunks(subchunks);

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_CHUNK <name="ENVL">;

string fn_Read_Type(ulong &type)
{
	switch (type)
	{
		case 0:
		{
			return "Float";
		}
		case 1:
		{
			return "Integer";
		}
		default:
		{
			Warning ("Unknown Envelope type.");
			return "Unknown type";
		}
	}
}

// ACTN chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    string          name<name="Name   ">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;

    string          type<name="Type   ">;
    if (sizeof(type) & 1)
        uchar padding <hidden=true>;

    ulong           identifier<name="Identifier">;
    //ushort   flags;
    local int subchunks = FTell();
    while( FTell() - pos < size )
        fn_Read_ACTN_Subchunks(subchunks);

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_CHUNK <read=fn_Read_ACTN, name="ACTN">;

string fn_Read_ACTN(ACTN_CHUNK &actn)
{
    string s;
    return SPrintf(s, "Type: '%s' Name: '%s' ", actn.type, actn.name);
}


// TAGS chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();

    typedef struct {
        string      tagname<name="Tag Name">;
        if (sizeof(tagname) & 1)
            uchar padding <hidden=true>;
    } TAGNAME <read=fn_Read_Tagname>;

		local uint count = 0;

    while( FTell() - pos < size )
    {
        TAGNAME  tag<name="Tag">;
        count += 1;
    }

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} TAGS_CHUNK <name="TAGS", read=fn_Read_TAGS>;

string fn_Read_Tagname(TAGNAME &tag)
{
    return tag.tagname;
}

string fn_Read_TAGS(TAGS_CHUNK &tags)
{
	string s;
	return SPrintf(s, "%u", tags.count);
}

// CHNM chunk
typedef struct
{
	string name<name="Name">;
	if (sizeof(name) & 1)
	    uchar padding <hidden=true>;
} channel_name_t <name="Channel Name", read=fn_Read_Channel_Name>;

string fn_Read_Channel_Name(channel_name_t &chnm)
{
	return chnm.name;
}

typedef struct
{
    ID              	chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           	size<name="Size">;
    ulong           	count<name="Count">;
  	channel_name_t		channel_name[count]<name="Channel Name", optimize=false>;

    // Padding so the next chunk starts on an even byte
    if ((size & 1) && (FTell() < FileSize()))
        uchar padding <hidden=true>;
} CHNM_CHUNK <name="CHNM", read=fn_Read_CHNM>;

string fn_Read_CHNM(CHNM_CHUNK &chnm)
{
	string s;
	return SPrintf(s, "%u", chnm.count);
}

// REFS chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ulong           refscount<name="Refs Count">;
    typedef struct {
        string          filepath<name="File">;
        if (sizeof(filepath) & 1)
            uchar padding <hidden=true>;
    } FILESPEC <read=fn_Read_Filespec>;
    local int i;
    for( i=0; i<refscount; i++ )
        FILESPEC  ref;
    local int subchunks = FTell();
    while( FTell() - pos < size )
        fn_Read_REFS_Subchunks(subchunks);
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} REFS_CHUNK <name="REFS">;

string fn_Read_Filespec(FILESPEC &ref)
{
    return ref.filepath;
}


// LAYR chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ushort          legacyIndex<name="(legacy) Index">;
    ushort          flags<format=binary, name="Flags">; 
    POINT_t         rotationPivot<name="Rotation Pivot">;
    string          layerName<name="Layer Name">;
    if (sizeof(layerName) & 1)
        uchar padding <hidden=true>;
    ushort          legacyParentIndex<name="(legacy) Parent Index">;
    float           subdivRefineLevel<name="Subdiv Refinement Level">;
    float           freezeCurveRefineLevel<name="Curve Refinement Level">;
    POINT_t         scalePivot<name="Scale Pivot">;
    ulong           unusedU4[6]<name="Reserved">;
    ulong           itemReference<name="Item Reference">;
    ushort          splineRefineLevel<name="Spline Refinement Level">;
    ushort          unusedU2[3]<name="Unused">;
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[size - (FTell() - pos)]<name="Usually PSub Displaement Related">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} LAYR_CHUNK <read=fn_Read_LAYR, name="LAYR">;

string fn_Read_LAYR(LAYR_CHUNK &layr)
{
    string s;
    return SPrintf( s, "%s", layr.layerName );
}


// PNTS chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    POINT_t         points[size/12]<name="Points">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PNTS_CHUNK <read=fn_Read_PNTS, name="PNTS">;

string fn_Read_PNTS(PNTS_CHUNK &pnts)
{
    string s;
    return SPrintf( s, "%d", pnts.size/12 );
}


// BBOX chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    POINT_t         min<name="Min">;
    POINT_t         max<name="Max">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} BBOX_CHUNK <read=fn_Read_BBOX, name="BBOX">;

string fn_Read_BBOX(BBOX_CHUNK &bbox)
{
    string s;
    return SPrintf( s, "Min: (%s), Max: (%s)", fn_Read_Point(bbox.min), fn_Read_Point(bbox.max) );
}


// VMPA chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    ulong           flags1<format=binary, name="Flags 1">; 
    ulong           flags2<format=binary, name="Flags 2">; 
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VMPA_CHUNK <name="VMPA">;


// VMAP chunk

typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Map Type   ">;
    ushort          dimension<name="Dimension">;
    string          name<name="Name   ">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    typedef struct
    {
        local ushort tmpIndex;
        tmpIndex = ReadUShort(FTell());
        if (tmpIndex < 0xFF00)
            ushort  index<name="Index">;
        else
            ulong   index<name="Index">;
        float           values[dimension];
    } vmap_point_t<name="Point">;
    while(FTell() - pos < size)
        vmap_point_t     point;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VMAP_CHUNK <read=fn_Read_VMAP, name="VMAP">;

string fn_Read_VMAP(VMAP_CHUNK &vmap)
{
    string s;
    return SPrintf(s, "Type: '%s' Name: '%s'", vmap.type, vmap.name);
}


// POLS Chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              polygon_type<name="PolyType", read=fn_Read_PolyType>;
    
    typedef struct
    {
        local ushort tmpindex = ReadUShort(FTell());
        if (tmpindex < 0xFF00)
            ushort  index;
        else
            ulong   index;
    } VERTINDEX_t<name="Index", read=fn_Read_VertIndex>;

		typedef struct
		{
      ushort nverts<name="Vert Count">;
      if ("CURV" == polygon_type || "BEZR" == polygon_type)
      {
          ulong flags = (nverts & 0xfc00) >> 10;        // get curve flags
          nverts &= 0x3ff;                        // mask off curve flags
      }
      else if ("HCRV" == polygon_type || "BCRV"  == polygon_type)
      {
          ulong flags;
          VERTINDEX_t vertIndex[nverts] <optimize=false>;
          break;
      }
      if ("CURV" == polygon_type || "BEZR" == polygon_type)
          if (nverts < 4 || 1 != (nverts % 3))        // Skip invalid bezier curves
              continue;
      VERTINDEX_t vertIndex[nverts] <optimize=false>;
		} POLY_t <name="Poly">;
    
    local uint count = 0;
    
    while(FTell() - pos < size)
    {
    	POLY_t		poly;
    	count += 1;
    }
        
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} POLS_CHUNK <name="POLS", read=fn_Read_POLS>;

string fn_Read_VertIndex(VERTINDEX_t &index)
{
    string s;
    int i = (int)index.index;
    if (sizeof(index) == 4)
		{
			//ULong Index
			i &= 0x00FFFFFF;
		}
    return SPrintf(s, "%i", i);
}

string fn_Read_PolyType(ID &type)
{
	string s;
	return SPrintf(s, "%s", type);
}

string fn_Read_POLS(POLS_CHUNK &pols)
{
	string s;
	return SPrintf(s, "%u", pols.count);
}

// VMAD chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Type   ">;
    ushort          dimension<name="Dimension">;
    string          name<name="Name">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    
    while( FTell() - pos < size )
        VERTDATA    data;
    
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VMAD_CHUNK <read=fn_Read_VMAD, name="VMAD">;

string fn_Read_VMAD(VMAD_CHUNK &vmad)
{
    string s;
    return SPrintf(s, "Type: '%s' Name: '%s'", vmad.type, vmad.name);
}


// VMED chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    ID              type<name="Type   ">;
    ushort          dimension<name="Dimension">;
    string          name<name="Name   ">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    
    while( FTell() - pos < size )
        VERTDATA    data;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VMED_CHUNK <read=fn_Read_VMED, name="VMED">;

string fn_Read_VMED(VMED_CHUNK &vmed)
{
    string s;
    return SPrintf(s, "Type: '%s' Name: '%s'", vmed.type, vmed.name);
}


// PTAG chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Type">;
		typedef struct
		{
			{
				local ushort tmpIndex = ReadUShort(FTell());
				if (tmpIndex < 0xFF00)
					ushort  polyIndex<name="PolyIndex">;
				else
					ulong   polyIndex<name="PolyIndex">;
			}

			ushort      tagIndex<name="TagIndex">;
			local string temp_tag_name = TAGS.tag[tagIndex].tagname;
		} PTAG_t<name="PTAG", read=fn_Read_PTAG>;
		
		while(FTell() - pos < size)
			PTAG_t ptag<name="PTag">;
 
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PTAG_CHUNK <read=PTAG_CHUNKRead, name="PTAG">;

string PTAG_CHUNKRead(PTAG_CHUNK &ptag) {
    string s;
    return SPrintf( s, "Type: '%s'", ptag.type );
}

string fn_Read_PTAG(PTAG_t &tag)
{
	return tag.temp_tag_name;
}

// 3GRP chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    ulong           numTriSurfs<name="Trisurf Count">;
    ulong           itemReference<name="Item Ref">;
    ulong           flags<format=binary, name="Flags">; 
     // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} _3GRP_CHUNK <name="3GRP", read=fn_Read_3GRP>;

string fn_Read_3GRP(_3GRP_CHUNK &_3grp)
{
	string s;
	return SPrintf(s, "TriSurfs: %u, ItemRef: %u", _3grp.numTriSurfs, _3grp.itemReference);
}


// 3SRF chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    ulong           numVerts<name="Num Verts">;
    numTriSurfVerts = numVerts;
    ulong           numTris<name="Num Tris">;
    numTriSurfTris = numTris;
    ulong           numVVEC<name="Num VVEC">;
    ulong           numTags<name="Num Tags">;
    numTriSurfTags = numTags;
    ulong           flags<format=binary, name="Flags">; 

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} _3SRF_CHUNK <name="3SRF", read=fn_Read_3SRF>;

string fn_Read_3SRF(_3SRF_CHUNK &_3srf)
{
	string s;
	return SPrintf(s, "Verts: %u, Tris: %u, VVec: %u, Tags: %u", _3srf.numVerts, _3srf.numTris, _3srf.numVVEC, _3srf.numTags);
}

// VRTS chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    POINT_t         verts[numTriSurfVerts]<name="Verts">;
     // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VRTS_CHUNK <read=VRTS_CHUNKread, name="VRTS">;

string VRTS_CHUNKread(VRTS_CHUNK &vrts)
{
    string  s;
    return SPrintf(s, "%d", numTriSurfVerts);
}


// TRIS chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    struct tri {
        ulong   vertA;
        ulong   vertB;
        ulong   vertC;
    };
    tri        triangles[numTriSurfTris]<name="Triangles   ">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} TRIS_CHUNK <read=TRIS_CHUNKread, name="TRIS">;

string TRIS_CHUNKread(TRIS_CHUNK &tris)
{
    string  s;
    return SPrintf(s, "%d", numTriSurfTris);
}


// VVEC chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Type">;
    ulong           dimension<name="Dimension">;
    string          vectorName<name="Vector Name">;
    if (sizeof(vectorName) & 1)
        uchar padding <hidden=true>;
    typedef struct
    {
        float   value[dimension]<name="Value">;
    } VVEC_Vector_t;
    while( FTell() - pos < size )
        VVEC_Vector_t         v<name="Vector">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VVEC_CHUNK <read=fn_Read_VVEC, name="VVEC">;

string fn_Read_VVEC(VVEC_CHUNK &vvec)
{
    string  s;
    return  SPrintf(s, "Type: '%s' Name: '%s'", vvec.type, vvec.vectorName);
}

// TTGS chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    
    typedef struct
    {
        ID          type<name="Type">;
        string      value<name="Value">;
        if (sizeof(value) & 1)
            uchar padding <hidden=true>;
    } TSTAG;
    
    TSTAG           triSurfTags[numTriSurfTags]<optimize=false, name="Tag", read=fn_Read_TSTAG>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} TTGS_CHUNK <name="TTGS", read=fn_Read_TTGS>;

string fn_Read_TSTAG(TSTAG &tag)
{
    string s;
    return SPrintf(s, "Type: '%s' Value: '%s'", tag.type, tag.value);
}

string fn_Read_TTGS(TTGS_CHUNK &tritag)
{
    string s;
    return SPrintf(s, "%u", numTriSurfTags);
}


// AUTH chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    string          authorName<name="Author   ">;
    if (sizeof(authorName) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} AUTH_CHUNK <read=AUTH_CHUNKread, name="AUTH">;

string AUTH_CHUNKread(AUTH_CHUNK &auth)
{
    return auth.authorName;
}


// (c) chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    string          dateAndHolder<name="Date & Holder   ">;
    if (sizeof(dateAndHolder) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} CPYR_CHUNK <read=CPYR_CHUNKread, name="CPYR">;

string CPYR_CHUNKread(CPYR_CHUNK &cpyr)
{
    return cpyr.dateAndHolder;
}


// ANNO chunk
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    string          annotation<name="Annotation   ">;
    if (sizeof(annotation) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ANNO_CHUNK <read=ANNO_CHUNKread, name="ANNO">;

string ANNO_CHUNKread(ANNO_CHUNK &anno)
{
    return anno.annotation;
}


// AANI CHUNK
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    local int pos = FTell();
    local int subchunks = FTell();
    while( FTell() - pos < size )
        fn_Read_AANI_Subchunks(subchunks);
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];
    

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} AANI_CHUNK <name="ANNI">;

// APPV CHUNK
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    ulong           majorVersion<name="Major Version">;
    ulong           minorVersion<name="Minor Version">;
    ulong						somethingVersion<name="Something Version">;
    ulong						buildVersion<name="Build Version">;
    string          application<name="Application">;
    if (sizeof(application) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} APPV_CHUNK<name="APPV">;


// IASS CHUNK
typedef struct
{
		ID							chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    if (size > 0)
    	uchar     			unknownData[size];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} IASS_CHUNK<name="IASS">;

// BAKE CHUNK
typedef struct
{
    ID              chunkID<name="ChunkID", fgcolor=cRed>;
    CSIZE           size<name="Size">;
    ulong           refID<name="Ref ID">;
    ulong           samples<name="Samples">;
    float           starttime<name="Start Time">;
    float           samples_per_sec<name="Samples Per Sec">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} BAKE_CHUNK <name="BAKE">;


//------------------------------------------------------------
// Item subchunk definitions.
//------------------------------------------------------------

// LINK subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      graphName<name="Graph Name">;
    if (sizeof(graphName) & 1)
        uchar padding <hidden=true>;
    long        itemID<name="Item ID">;
    long        itemIndex<name="Item Index">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_LINK_SUBCHUNK <read=fn_Read_ITEM_LINK, name="LINK">;

string fn_Read_ITEM_LINK(ITEM_LINK_SUBCHUNK &link)
{
    string s;
    return SPrintf(s, "Graph: %s", link.graphName);
}


//enum <ushort> ENUM1{              // Item Data Types
//    LXItemType_Int              = 0x01,
//    LXItemType_Float            = 0x02,
//    LXItemType_String           = 0x03,
//    LXItemType_Variable         = 0x04,
//    LXItemType_Envelope         = 0x10,
//    LXItemType_UndefState       = 0x20,     // undefined action channel
//
//    LXItemType_EnvelopeInt      = LXItemType_Envelope | LXItemType_Int,
//    LXItemType_EnvelopeFloat    = LXItemType_Envelope | LXItemType_Float,
//    LXItemType_EnvelopeString   = LXItemType_Envelope | LXItemType_String,
//
//    LXItemType_FloatAlt         = 0x4e56,   // compatibility with some apps
//
//    LXEnvelopeType_Float        = 0,
//    LXEnvelopeType_Int          = 1,
//    };


// CHNL subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      chnlName<name="Channel Name">;
    // pad to even byteif needed
    if (sizeof(chnlName) & 1)
        uchar padding <hidden=true>;
    ushort       datatype<name="Datatype">;
    
    switch (datatype & ~LXItemType_UndefState) {
        case LXItemType_Int:
        case LXItemType_EnvelopeInt:
            long     data<name="Data">;
            break;
        case LXItemType_Float:
        case LXItemType_FloatAlt:
        case LXItemType_EnvelopeFloat:
            float   data<name="Data">;
            break;
        case LXItemType_String:
        case LXItemType_EnvelopeString:
            string      data<name="Data   ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
    }

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHNL_SUBCHUNK <name="CHNL", read=fn_Read_ITEM_CHNL>;

string fn_Read_ITEM_CHNL(ITEM_CHNL_SUBCHUNK &chnl)
{
    return chnl.chnlName;
}


// CHNS subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      chnlName<name="Channnel Name">;
    // pad to even byteif needed
    if (sizeof(chnlName) & 1)
        uchar padding <hidden=true>;
    string      chnlvalue<name="Channel Value">;
    // pad to even byteif needed
    if (sizeof(chnlvalue) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHNS_SUBCHUNK <read=fn_Read_ITEM_CHNS, name="CHNS">;

string fn_Read_ITEM_CHNS(ITEM_CHNS_SUBCHUNK &chns)
{
    string s;
    return SPrintf(s, "%s: %s", chns.chnlName, chns.chnlvalue);
}


// CHNV subchunk
typedef struct
{
    local int   start = FTell();
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    local int pos = FTell();
    string      chnlName<name="Channel Name">;
    // pad to even byteif needed
    if (sizeof(chnlName) & 1)
        uchar padding <hidden=true>;
    short       datatype<name="Datatype">;
    short       elements<name="Elements">;

    struct
    {
        string      vectorname<name="Vector Name">;
        // pad to even byteif needed
        if (sizeof(vectorname) & 1)
            uchar padding <hidden=true>;

        switch (datatype & ~0x20) {
        case 1: 
            long     data<name="Data">;
            break;
        case 2: 
            float   data<name="Data">;
            break;
        case 3:
            string      data<name="Data">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
        }
    }values[elements] <optimize=false>;


    // Deal with any unknown data at the end of the chunk
    if( size > (FTell() - pos) ){
        uchar unknown[ size - (FTell() - pos) ];
        Printf( "Encountered unknown data at end of '%s' subchunk. at position %Ld.\n", subchunkID, start );
        }
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHNV_SUBCHUNK <read=fn_Read_ITEM_CHNV, name="CHNV">;

string fn_Read_ITEM_CHNV(ITEM_CHNV_SUBCHUNK &chnv)
{
    return chnv.chnlName;
}


// LAYR subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       index<name="Index">;
    ulong       flags<format=binary, name="Flags">;   //need to come back to these
    RGBA        wireColor<name="Wire Color">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_LAYR_SUBCHUNK <name="LAYR">;


// UCHN subchunk
typedef struct
{
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local int       pos = FTell();
    string          chanName<name="Channel Name">;
    // pad to even byteif needed
    if (sizeof(chanName) & 1)
        uchar padding <hidden=true>;
    string          chanType<name="Channel Type">;
    // pad to even byteif needed
    if (sizeof(chanType) & 1)
        uchar padding <hidden=true>;
    ulong           vecMode<name="Vector Mode">;  // come back to this
    ulong           flags<format=binary, name="Flags">; 
    long            defaultInt<name="Default Int">;
    float           defaultFloat<name="Default Float">;
    ushort          numHints<name="Num Hints">;
    if (numHints) {
        struct {
            string      hintName<name="Hint Name">;
            // pad to even byteif needed
            if (sizeof(hintName) & 1)
                uchar padding <hidden=true>;
            long        hintValue<name="Hint Value">;
        } hints[numHints] <optimize=false>;
    }

    // Deal with any unknown data at the end of the chunk
    if( size > (FTell() - pos) )
    {
        local int start = FTell();
        uchar unknown[ size - (start - pos) ];
        Printf( "Encountered unknown data at end of ITEM subchunk %s. at position %Ld.\n", subchunkID, start );
    }
    
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_UCHN_SUBCHUNK <read=fn_Read_ITEM_UCHN, name="UCHN">;

string fn_Read_ITEM_UCHN(ITEM_UCHN_SUBCHUNK &uchn)
{
    return uchn.chanName;
}


// UNIQ subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      identifier<name="Identifier">;
    // pad to even byteif needed
    if (sizeof(identifier) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_UNIQ_SUBCHUNK <read=fn_Read_ITEM_UNIQ, name="UNIQ">;

string fn_Read_ITEM_UNIQ(ITEM_UNIQ_SUBCHUNK &uniq) {
    string s;
    return SPrintf(s, "%s", uniq.identifier);
}


// ITAG subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ID          type<name="Tag Type">;
    string      value<name="Tag Value">;
    // pad to even byteif needed
    if (sizeof(value) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_ITAG_SUBCHUNK <read=fn_Read_ITEM_ITAG, name="ITAG">;

string fn_Read_ITEM_ITAG(ITEM_ITAG_SUBCHUNK &itag)
{
    string s;
    return SPrintf(s, "%s: %s", itag.type, itag.value);
}

// UIDX subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    long        index<name="Index">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_UIDX_SUBCHUNK <name="UIDX", read=fn_Read_ITEM_UIDX>;

string fn_Read_ITEM_UIDX(ITEM_UIDX_SUBCHUNK &uidx)
{
	string s;
	return SPrintf(s, "%u", uidx.index);
}

// GRAD subchunk

typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    local int pos = FTell();
    string      channelName<name="Channel Name">;
    // pad to even byteif needed
    if (sizeof(channelName) & 1)
        uchar padding <hidden=true>;
    local ushort tmpIndex;
    tmpIndex = ReadUShort(FTell());
    if (tmpIndex < 0xFF00)
        ushort index<name="Index">;
    else
        ulong index<name="Index">;
    ulong   interpolationFlags<format=binary>; 
    if( size > (FTell() - pos) )
    {
	    string      intype<name="In-Type   ">;
	    // pad to even byteif needed
	    if (sizeof(intype) & 1)
	        uchar padding <hidden=true>;
	    string      outtype<name="Out-Type   ">;
	    // pad to even byteif needed
	    if (sizeof(outtype) & 1)
        uchar padding <hidden=true>;
    }

    //    uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_GRAD_SUBCHUNK <read=fn_Read_ITEM_GRAD, name="GRAD">;

string fn_Read_ITEM_GRAD(ITEM_GRAD_SUBCHUNK &grad)
{
    return grad.channelName;
}



// PAKG subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      name<name="Name">;
    // pad to even byteif needed
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    ulong       datasize<name="Datasize">;
    if (datasize > 0)
        uchar       data[datasize];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_PAKG_SUBCHUNK <read=fn_Read_ITEM_PAKG, name="PAKG">;

string fn_Read_ITEM_PAKG(ITEM_PAKG_SUBCHUNK &pakg)
{
    string s;
    return SPrintf(s, "Type: %s", pakg.name);
}


// CHAN Subchunk
typedef struct
{
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local int       pos = FTell();
    local ushort    tmpIndex;
    tmpIndex = ReadUShort(FTell());
    if (tmpIndex < 0xFF00)
        ushort          channelIndex<name="Channel Index">;
    else
        ulong           channelIndex<name="Channel Index">;
    local string temp_channel_name = CHNM.channel_name[channelIndex].name;
    ushort          datatype<name="Datatype", read=fn_Read_Datatype>;
    switch (datatype & ~0x20)
    {
        case 1: 
            int     data<name="Integer">;
            break;
        case 2: 
            float   data<name="Float">;
            break;
        case 3:
            string      data<name="String (Hint)">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
        case 17: 
            int     data<name="Integer (w/Envelope)">;
            break;
        case 18:
            float   data<name="Float (w/Envelope)">;
            break;
        case 19:
            string      data<name="String (Hint)(w/Envelope)">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
    }

    // Unknown data at the end of the chunk
    if(size > (FTell() - pos))
        uchar value[size - (FTell() - pos)];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHAN_SUBCHUNK <name="CHAN", read=fn_Read_ITEM_CHAN>;

string fn_Read_ITEM_CHAN(ITEM_CHAN_SUBCHUNK &chan)
{
	return chan.temp_channel_name;
}

string fn_Read_Datatype(ushort &type)
{
    switch (type & ~0x20)
    {
        case 1: 
            return "Integer";
        case 2: 
            return "Float";
        case 3:
            return "String (Hint)";
        case 17: 
            return "Integer (w/Envelope)";
        case 18:
            return "Float (w/Envelope)";
        case 19:
            return "String (Hint)(w/Envelope)";
        default:
        	{
        		Warning("Unknown Channel Type!");
        		return "Unknown Channel Type!";
        	}
    }
}

// XREF subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       subsceneIndex<name="SubScene Index">;
    string      filename<name="Filename">;
    if (sizeof(filename) & 1)
        uchar padding <hidden=true>;
    string      itemIdentifier<name="Identifier">;
    if (sizeof(itemIdentifier) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_XREF_SUBCHUNK <read=fn_Read_ITEM_XREF, name="XREF">;

string fn_Read_ITEM_XREF(ITEM_XREF_SUBCHUNK &xref)
{
    return xref.filename;
}


// CLNK subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      graphName<name="Graph name   ">;
    if (sizeof(graphName) & 1)
        uchar padding <hidden=true>;
    string      fromChannel<name="From-Channel   ">;
    if (sizeof(fromChannel) & 1)
        uchar padding <hidden=true>;
    ulong       fromItemID<name="From-Item ID">;
    string      toName<name="To-Name   ">;
    if (sizeof(toName) & 1)
        uchar padding <hidden=true>;
    ulong       fromIndex<name="From-Index">;
    ulong       toIndex<name="To-Index">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CLNK_SUBCHUNK <read=fn_Read_ITEM_CLNK, name="CLNK">;

string fn_Read_ITEM_CLNK(ITEM_CLNK_SUBCHUNK &clnk)
{
    string s;
    return SPrintf(s, "Graph: %s   From: %s   To: %s", clnk.graphName, clnk.fromChannel, clnk.toName);
}


// PRVW subchunk
typedef struct
{
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local int       pos = FTell();
    unsigned short  width<name="Width">;
    unsigned short  height<name="Height">;
    unsigned long   type<name="Type">;
    unsigned long   flags<format=binary, name="Flags">; 
    char    previewData[size - (FTell() - pos)]<name="Preview Data">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_PRVW_SUBCHUNK <read=fn_Read_ITEM_PRVW, name="PRVW">;

string fn_Read_ITEM_PRVW(ITEM_PRVW_SUBCHUNK &prvw)
{
    string s;
    return SPrintf(s, "width: %d height: %d", prvw.width, prvw.height);
}


// BBOX chunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    POINT_t     min<name="Min">;
    POINT_t     max<name="Max">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_BBOX_SUBCHUNK <read=fn_Read_ITEM_BBOX, name="BBOX">;

string fn_Read_ITEM_BBOX(ITEM_BBOX_SUBCHUNK &bbox)
{
    string s;
    return SPrintf( s, "Min: (%s), Max: (%s)", fn_Read_Point(bbox.min), fn_Read_Point(bbox.max) );
}

// CHNC chunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    uchar        data[size];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHNC_SUBCHUNK <name="CHNC">;

// ITEM_VNAM_SUBCHUNK
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      name<name="Name">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_VNAM_SUBCHUNK <name="VNAM", read=fn_Read_ITEM_VNAM>;

string fn_Read_ITEM_VNAM(ITEM_VNAM_SUBCHUNK &vnam)
{
	return vnam.name;
	string s;
	return SPrintf(s, "%s", vnam.name);
}

//------------------------------------------------------------
// ENVL subchunk definitions.
//------------------------------------------------------------

// PRE subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ushort      behaviour<name="Behaviour">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_PRE <read=fn_Read_ENVL_PRE, name="PRE">;

string fn_Read_ENVL_PRE(ENVL_PRE &chunk)
{
    switch(chunk.behaviour)
    {
        case 0: return "Reset";
        case 1: return "Constant (Smooth)";
        case 2: return "Repeat";
        case 3: return "Oscillate (Smooth)";
        case 4: return "Offset Repeat (Smooth)";
        case 5: return "Linear";
        case 6: return "Constant";
        case 7: return "Oscillate";
        case 8: return "Offset Repeat";
    }
}


// POST subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ushort      behaviour<name="Behaviour">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_POST_SUBCHUNK <read=fn_Read_ENVL_POST, name="POST">;

string fn_Read_ENVL_POST(ENVL_POST_SUBCHUNK &chunk)
{
    switch(chunk.behaviour)
    {
        case 0: return "Reset";
        case 1: return "Constant (Smooth)";
        case 2: return "Repeat";
        case 3: return "Oscillate (Smooth)";
        case 4: return "Offset Repeat (Smooth)";
        case 5: return "Linear";
        case 6: return "Constant";
        case 7: return "Oscillate";
        case 8: return "Offset Repeat";
    }
}


// KEY subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    float       time<name="Time">;
    float       value<name="Value">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_KEY <read=fn_Read_ENVL_KEY, name="KEY">;

string fn_Read_ENVL_KEY(ENVL_KEY &chunk)
{
    string s;
    return SPrintf(s, "%f @ %f", chunk.value, chunk.time);
}


// IKEY subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    float       time<name="Time">;
    ulong       value<name="Value">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_IKEY_SUBCHUNK <read=fn_Read_ENVL_IKEY, name="IKEY">;

string fn_Read_ENVL_IKEY(ENVL_IKEY_SUBCHUNK &chunk)
{
    string s;
    return SPrintf(s, "%f", chunk.value);
}


// TANI subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ushort      slopeType<name="Slope Type", read=fnRead_SlopeType>;
    ushort      weightType<name="Weight Type", read=fnRead_WeightType>;
    float       weight<name="Weight">;
    float       slope<name="Slope">;
    float       value<name="Value">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_TANI_SUBCHUNK<name="TANI">;

// TANO subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       breaks<name="Breaks">;
    ushort      slopeType<name="Slope Type", read=fnRead_SlopeType>;
    ushort      weightType<name="Weight Type", read=fnRead_WeightType>;
    float       weight<name="Weight">;
    float       slope<name="Slope">;
    float       value<name="Value">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_TANO_SUBCHUNK<name="TANO">;

string fnRead_SlopeType(ushort type)
{
	switch (type)
	{
		case 0:
			return "Manual";
		case 1:
			return "Automatic";
		case 2:
			return "Linear In";
		case 4:
			return "Linear Out";
		case 8:
			return "Flat";
		case 16:
			return "Auto Flat";
		case 32:
			return "Stepped";
		case 64:
			return "Smooth Flat";
		default:
			return "Unknown";
	}
}

string fnRead_WeightType(ushort type)
{
	switch (type)
	{
		case 0:
			return "Manual";
		case 1:
			return "Automatic";
		default:
			return "Unknown";
	}
}

// FLAG subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       flags<format=binary, name="Flags">; 

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_FLAG_SUBCHUNK <read=fn_Read_ENVL_FLAG, name="FLAG">;

string fn_Read_ENVL_FLAG(ENVL_FLAG_SUBCHUNK &chunk)
{
    return "Deprecated";
}



//------------------------------------------------------------
// ACTN subchunk definitions.
//------------------------------------------------------------

// ITEM subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       identifier<name="Identifier">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_ITEM_SUBCHUNK<name="ITEM">;


// GRAD subchunk
typedef struct
{
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local int       pos = FTell();
    local ushort    tmpChnlNameIdx;
    tmpChnlNameIdx = ReadUShort(FTell());
    if (tmpChnlNameIdx < 0xFF00)
        ushort      nameIndex<name="Channel Name Index">;
    else
        ulong       nameIndex<name="Channel Name Index">;
    local ushort    tmpEnvlIdx;
    tmpEnvlIdx = ReadUShort(FTell());
    if (tmpEnvlIdx < 0xFF00)
        ushort  envelopeIndex<name="Envelope Index">;
    else
        ulong   envelopeIndex<name="Envelope Index">;
    ulong   flags<format=binary>; 
    if (size > 8) {
    string          name<name="Name   ">;
    // pad to even byteif needed
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    if( size > (FTell() - pos) ){
        string  intype<name="In-Type   ">;
        // pad to even byteif needed
        if (sizeof(intype) & 1)
            uchar padding <hidden=true>;
        string  outtype<name="Out-Type   ">;
        // pad to even byteif needed
        if (sizeof(outtype) & 1)
            uchar padding <hidden=true>;
    }
}
    //    uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_GRAD_SUBCHUNK<read=fn_Read_ACTN_GRAD, name="GRAD">;

string fn_Read_ACTN_GRAD(ACTN_GRAD_SUBCHUNK &grad)
{
    return grad.name;
}


// PRNT subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       identifier<name="Identifier">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_PRNT_SUBCHUNK<name="PRNT">;


// CHAN subchunk
typedef struct
{
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local ushort    tmpChnlNameIdx;
    tmpChnlNameIdx = ReadUShort(FTell());
    if (tmpChnlNameIdx < 0xFF00)
        ushort      nameIndex<name="Channel Name Index">;
    else
        ulong       nameIndex<name="Channel Name Index">;
    ushort          datatype<name="Datatype">;  
    local ushort    tmpEnvlIdx;
    if (tmpEnvlIdx < 0xFF00)
        ushort      envelopeIndex<name="Envelope Index">;
    else
        ulong       envelopeIndex<name="Envelope Index">;
    local string temp_channel_name = CHNM.channel_name[nameIndex].name;
    switch (datatype & ~0x20) {
        case 1: 
            int     data<name="Data">;
            break;
        case 2: 
            float   data<name="Data">;
            break;
        case 3:
            string      data<name="Data  ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
        case 17: 
            int     data<name="Data">;
            break;
        case 18:
            float   data<name="Data">;
            break;
        case 19:
            string      data<name="Data">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
    }


    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_CHAN_SUBCHUNK<name="CHAN", read=fn_Read_ACTN_CHAN>;

string fn_Read_ACTN_CHAN(ACTN_CHAN_SUBCHUNK &chan)
{
	string s;
	return SPrintf(s, "%s", chan.temp_channel_name);
}

// CHNS subchunk
typedef struct
{
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    string          channelName<name="Channel Name">;
    // pad to even byteif needed
    if (sizeof(channelName) & 1)
        uchar padding <hidden=true>;
    local ushort    tmpChnlIdx;
    tmpChnlIdx = ReadUShort(FTell());
    if (tmpChnlIdx < 0xFF00)
        ushort  channelIndex<name="Channel Index">;
    else
        ulong   channelIndex<name="Channel Index">;
    string          value<name="Value  ">;
    // pad to even byteif needed
    if (sizeof(value) & 1)
        uchar padding <hidden=true>;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_CHNS_SUBCHUNK<read=fn_Read_ACTN_CHNS, name="CHNS">;

string fn_Read_ACTN_CHNS(ACTN_CHNS_SUBCHUNK &chns)
{
    string s;
    return SPrintf(s, "Name: %s   Value: %s", chns.channelName, chns.value);
}


// CHNN subchunk
typedef struct
{
    ID          		subchunkID<name="Subchunk ID">;
    SCSIZE      		size<name="Subchunk Size">;
    string          channelName<name="Channel Name">;
    // pad to even byteif needed
    if (sizeof(channelName) & 1)
        uchar padding <hidden=true>;
    ushort          datatype<name="DataType">;
    local ushort    tmpEnvlIdx;
    tmpEnvlIdx = ReadUShort(FTell());
    if (tmpEnvlIdx < 0xFF00)
        ushort  envelopeIndex<name="Envelope Index">;
    else
        ulong   envelopeIndex<name="Envelope Index">;
    switch (datatype) {
        case 1: 
            int     data<name="Data">;
            break;
        case 2: 
            float   data<name="Data">;
            break;
        case 3:
            string      data<name="Data   ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
        case 17: 
            int     data<name="Data">;
            break;
        case 18:
            float   data<name="Data">;
            break;
        case 19:
            string      data<name="Data   ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
    }

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_CHNN_SUBCHUNK<read=fn_Read_ACTN_CHNN, name="CHNN">;

string fn_Read_ACTN_CHNN(ACTN_CHNN_SUBCHUNK &chnn)
{
    return chnn.channelName;
}


//------------------------------------------------------------
// AANI subchunk definitions.
//------------------------------------------------------------

// AAIT subchunk
typedef struct
{
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    ulong           itemrefindex<name="Item Ref Index">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} AANI_AAIT_SUBCHUNK<name="AAIT">;


// AASE subchunk
typedef struct
{
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    ushort          loopmode<name="Loop Mode">;
    ushort          mutestate<name="Mute State">;
    ushort          scrubstate<name="Scrub State">;
    float           starttime<name="Start Time">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} AANI_AASE_SUBCHUNK<name="AANI">;



//------------------------------------------------------------
// REFS subchunk definitions.
//------------------------------------------------------------

// IDEL subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    local int pos = FTell();
    ulong           index<name="Index">;
    
    string          refname<name="Ref Name">;
    // pad to even byteif needed
    if (sizeof(refname) & 1)
        uchar padding <hidden=true>;
    string          parentname<name="Parent Name">;
    // pad to even byteif needed
    if (sizeof(parentname) & 1)
        uchar padding <hidden=true>;
    typedef struct {
        string  refstring<name="Reference">;
        if (sizeof(refstring) & 1)
            uchar padding <hidden=true>;
    } REFSTRING <read=REFSTRING_Read>;

    while( FTell() - pos < size )
        REFSTRING  item;
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} REFS_IDEL_SUBCHUNK<name="REFS">;


// LOPT subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    local int pos = FTell();
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} REFS_LOPT_SUBCHUNK<name="LOPT">;



//------------------------------------------------------------
// catchall for chunks/subchunks we don't recognize
//------------------------------------------------------------
typedef struct
{
    ID          subchunkID<name="ChunkID", fgcolor=cRed>;
    SCSIZE      size<name="Chunk Size">;
    uchar     unknownData[size];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} UNKNOWNCHUNK<name="Unknown">;


// unknown subchunk
typedef struct
{
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    uchar       unknownData[size];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} UNKNOWNSUBCHUNK<name="Unknown">;



//------------------------------------------------------------
// misc utility data structures
//------------------------------------------------------------

// RGBA color
typedef struct {
    unsigned char R;
    unsigned char G;
    unsigned char B;
    unsigned char A;
} RGBA<name="RGBA">;


// point/vertex coordinate
typedef struct {
    float   X;
    float   Y;
    float   Z;
} POINT_t <read=fn_Read_Point, name="Point">;

string fn_Read_Point(POINT_t &point)
{
    string s;
    return SPrintf(s, "xyz: %f, %f, %f", point.X, point.Y, point.Z);
}


//used by VMAD and VMED chunks
typedef struct
{
        local ushort tmpIndex;
        tmpIndex = ReadUShort(FTell());
        if (tmpIndex < 0xFF00)
            ushort  indexInPNTS;
        else
            ulong   indexInPNTS;
        local ushort tmpIndex2;
        tmpIndex2 = ReadUShort(FTell());
        if (tmpIndex2 < 0xFF00)
            ushort  indexSharedPoly;
        else
            ulong   indexSharedPoly;
        if (dimension > 0)
            float           values[dimension];
} VERTDATA<name="Vertex Data">;



//------------------------------------------------------------
// subchunk reading functions
//------------------------------------------------------------

void fn_ReadItemSubchunks(int pos)
{
    local ID tag;
    local uint size;
    ReadBytes(tag,FTell(),4);

    // See which chunk this is
    switch(tag)
    {
        case "LINK":
            ITEM_LINK_SUBCHUNK LINK;
            break;
        case "CHNL":
            ITEM_CHNL_SUBCHUNK CHNL;
            break;
        case "CHNS":
            ITEM_CHNS_SUBCHUNK CHNS;
            break;
        case "CHNV":
            ITEM_CHNV_SUBCHUNK CHNV;
            break;
        case "UNIQ":
            ITEM_UNIQ_SUBCHUNK UNIQ;
            break;
        case "UIDX":
            ITEM_UIDX_SUBCHUNK UIDX;
            break;
        case "LAYR":
            ITEM_LAYR_SUBCHUNK LAYR;
            break;
        case "UCHN":
            ITEM_UCHN_SUBCHUNK UCHN;
            break;
        case "ITAG":
            ITEM_ITAG_SUBCHUNK ITAG;
            break;
        case "GRAD":
            ITEM_GRAD_SUBCHUNK GRAD;
            break;
        case "PAKG":
            ITEM_PAKG_SUBCHUNK PAKG;
            break;
        case "CHAN":
            ITEM_CHAN_SUBCHUNK CHAN;
            break;
        case "XREF":
            ITEM_XREF_SUBCHUNK XREF;
            break;
        case "CLNK":
            ITEM_CLNK_SUBCHUNK CLNK;
            break;
        case "PRVW":
            ITEM_PRVW_SUBCHUNK PRVW;
            break;
        case "BBOX":
            ITEM_BBOX_SUBCHUNK BBOX;
            break;
        case "CHNC":
            ITEM_CHNC_SUBCHUNK CHNC;
            break;
        case "VNAM":
        		ITEM_VNAM_SUBCHUNK VNAM;
        		break;
        default:
            size = ReadUInt( FTell()+4 );
            Printf( "Encountered unknown ITEM subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
            UNKNOWNSUBCHUNK unknown;
            break;
        }
}


void fn_Read_ENVL_Subchunks(int pos)
{
    local ID tag;
    local uint size;
    ReadBytes( tag, FTell(), 4 );

    // See which chunk this is
    switch(tag)
    {
        case "PRE ":
            ENVL_PRE PRE;
            break;
        case "POST":
            ENVL_POST_SUBCHUNK POST;
            break;
        case "KEY ":
            ENVL_KEY KEY;
            break;
        case "IKEY":
            ENVL_IKEY_SUBCHUNK IKEY;
            break;
        case "TANI":
            ENVL_TANI_SUBCHUNK TANI;
            break;
        case "TANO":
            ENVL_TANO_SUBCHUNK TANO;
            break;
        case "FLAG":
            ENVL_FLAG_SUBCHUNK FLAG;
            break;
        default:
            size = ReadUInt( FTell()+4 );
            Printf( "Encountered unknown ENVL subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
            UNKNOWNSUBCHUNK unknown;
            break;
        }
}


void fn_Read_ACTN_Subchunks(int pos)
{
    local ID tag;
    local uint size;
    ReadBytes( tag, FTell(), 4 );
    // See which chunk this is
    switch(tag)
    {
        case "ITEM":
            ACTN_ITEM_SUBCHUNK ITEM;
            break;
        case "GRAD":
            ACTN_GRAD_SUBCHUNK GRAD;
            break;
        case "PRNT":
            ACTN_PRNT_SUBCHUNK PRNT;
            break;
        case "CHAN":
            ACTN_CHAN_SUBCHUNK CHAN;
            break;
        case "CHNS":
            ACTN_CHNS_SUBCHUNK CHNS;
            break;
        case "CHNN":
            ACTN_CHNN_SUBCHUNK CHNN;
            break;
        default:
            size = ReadUInt( FTell()+4 );
            Printf( "Encountered unknown ACTN subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
            UNKNOWNSUBCHUNK unknown;
            break;
        }
}


void fn_Read_AANI_Subchunks(int pos)
{
  local ID tag;
  local uint size;
  ReadBytes( tag, FTell(), 4 );

  // See which chunk this is
  switch( tag )
  {
      case "AAIT":
          AANI_AAIT_SUBCHUNK AAIT;
          break;
      case "AASE":
          AANI_AASE_SUBCHUNK AASE;
          break;
      default:
          size = ReadUInt( FTell()+4 );
          Printf( "Encountered unknown AANI subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
          UNKNOWNSUBCHUNK unknown;
          break;
  }
}


void fn_Read_REFS_Subchunks(int pos)
{
  local ID tag;
  local uint size;
  ReadBytes( tag, FTell(), 4 );

  // See which chunk this is
  switch( tag )
  {
      case "IDEL":
          REFS_IDEL_SUBCHUNK IDEL;
          break;
      case "LOPT":
          REFS_LOPT_SUBCHUNK LOPT;
          break;
      default:
          size = ReadUInt( FTell()+4 );
          Printf( "Encountered unknown REFS subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
          UNKNOWNSUBCHUNK unknown;
          break;
  }
}


